<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title></title>
	<meta charset="utf-8" />
    <script>
       
        /** 
            该程序用于说明, 类式继承和构造函数式继承结合使用的效果.
        **/
        function SuperClass(name)
        {
            this.name = name;
            this.book = ['javascript','php','c++'];
        }



        SuperClass.prototype.getBook = function ()
        {
            return this.book;
        }


        function SubClass(name, time)
        {
            SuperClass.call(this, name);
            this.time = time;
        }


        SubClass.prototype = new SuperClass();

        var instance1 = new SubClass('instance1', 2011);
        var instance2 = new SubClass('instance2', 1999);

        instance1.book.push('java');
        console.log(instance1.getBook());
        console.log(instance2.getBook());
        console.log(instance1);
        console.log(instance2);





        /**
            通过测试 :
               于前期测试,相比较而言
               1  子类确实继承了父类的属性, 而且父类也拥有自己的属性,
               2  子类可以使用父类的中的方法, 弥补了构造函数式继承的缺点
               3  父类构造函数中赋值的操作,在子类实例化的过程中没有效果, 父类属性中undefined的值.
                  说白了,就是没有给父类的属性上赋值.


            虽然2中类的继承结合弥补了各自带来的缺陷,通过在类的继承过程中也出现了比较多余的操作, 
                1 修改子类的原型的时候, 调用了一次父类的构造函数.
                2 在实例化子类的时候, 又调用了一次父类的构造函数.


        **/


    </script>
</head>
<body>

</body>
</html>
